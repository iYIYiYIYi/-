    光栅显示器：可以看作一个像素矩阵，在光栅显示器上显示的任何一个图形，实际上都是一些具有一种或多种颜色的像素集合。

    光栅图形：对一个具体的光山县十七来说，像素个数是有限的，像素的颜色和灰度等级也是有限的，像素是有大小的，所以光栅图形只是近似的实际图形。
        ——光栅显示器上显示的图形，称为光栅图形
        ——图形光栅化之后，显示在屏幕上的一个窗口里，超出窗口的部分不予显示。确定一个图形的哪些部分在窗口内，必须显式;哪些部分在窗口外不予显示，即为“裁剪”
        ——在光栅图形中，非水平和垂直的直线用像素集合表示时，会呈锯齿状，这种现象称为走样，用于减少或消除走样的技术称为反走样


# 直线段的扫描转换算法
    通过求出直线的斜率，让x保持步进，每次步进一个像素单位，y每次步进一个斜率（并通过强制转换为int保留有效信息）

## 1、DDA画线算法
```cpp
void DDALine(int x0,int x1,int y0,int y1,int color)
{
    int x;
    float dx,dy,y,k;
    dx = x1 - x0;
    dy = y1 - y0;
    k = dy/dx;
    for(x=x0;x<=x1;x++)
    {
        drawPixel(x,(int)(y+0.5),color);
        y += k;
    }
}
```
上述算法仅适用于|k|<=1时的情况，若|k|>1，可以将y与x互换。y与k必须用浮点数表示，而且每一步都需要对y进行取整，这使得它不利于硬件实现。

## 2、中点画线法
    假设直线方程为F(x,y) = ax+by+c = 0;
    则可得出步进的下一个点的位置，若d = F(x1,y1) >= 0，则y++，否则y不变（前提是只考虑k大于0的情况）
    由于只需要知道d的符号就可以判断下一个像素点，为了避免小数，可以采用2*d进行运算。
```cpp
void MidpointLine(int x0,int y0,int x1,int y1,int color)
{
    int a,b,d1,d2,d,x,y;
    a = y0-y1;b = x1-x0;d = 2*a+b;
    d1 = 2*a;d2 = 2*a+b;
    x = x0;y = y0;

    while(x<x1)
    {
        if(d<0>)
        {
            x++;y++;d+=d2;
        }
        else
        {
            x++;d+=d1;
        }
        drawPixel(x,y,color);
    }
}
```
上述算法同样无法计算k>1，甚至无法计算k<0（可以通过优化if else结构支持k<0）

## 3、Bresenham算法
    设直线方程为y=kx+b，则可知下一步的y1=k(x1-x)+b=y+k，即下一个像素的列坐标x++,y=y或y++。y是否自增取决于误差项d的值。d+=k,若d>=0.5，则y++，若d<0.5，则y=y，且需要将d保持在0~1的范围之内，即当d>=1时，d--。

    将d的初始值设置为-0.5，便于通过符号判断

```cpp
void Bresenhamline (int x0,int y0,int x1, int y1,int color)
{ 
    int x, y, dx, dy;
    float k, e;
    dx = x1-x0;dy = y1- y0;k=dy/dx;
    e=-0.5;x=x0;y=y0;
    for (i=0;i<=dx;i++)
    { 
        drawpixel (x, y, color);
        x++;e=e+k;
        if (e>=0)
        {
            y++; 
            e=e-1;
        }  
    }
}
```
此算法依然没有考虑k>1和k<0

由于该算法使用了大量除法和浮点数，故可以将d替换为-dx，省去求k的步骤：
```cpp
void InterBresenhamline (int x0,int y0,int x1, int y1,int color)
{ 
    dx = x1-x0;dy = y1- y0;e=-dx;
    x=x0;y=y0;
    for (i=0; i<=dx; i++)
    {
        drawpixel (x, y, color);
        x++; e=e+2*dy;
        if (e>=0)
        { y++; e=e-2*dx;}
    }
}
```

# 圆、椭圆的扫描转换

## 1、八点画圆法
    圆是一个八对称图形，故将圆心设置为原点时，可以同时构造八段圆弧。
    当x==y时，停止画弧。

中点画圆算法：
```cpp
void MidPointCircle(int r, int color)
{ 
    int x,y;
    float d;
    x=0; y=r; d=1.25-r;
    circlepoints (x,y,color); //显示圆弧上的八个对称点
    while(x<=y)
    { 
        if(d<0) d+=2*x+3;
        else { d+=2*(x-y)+5; y--;}
        x++;
        circlepoints (x,y,color);
    }
}
```

```cpp
void circlepoints(int x,int y,int color)
{
    drawPixel(x,y,color);drawPixel(x,-y,color);
    drawPixel(-x,y,color);drawPixel(-x,-y,color);
    drawPixel(y,x,color);drawPixel(y,-x,color);
    drawPixel(-y,x,color);drawPixel(-y,-x,color);
}
```

## 2、椭圆的扫描转换算法
    椭圆斜率绝对值小于1时，在x方向取单位步长
    椭圆斜率绝对值大于1时，在y方向取单位步长
### 上半部分：
    
下一对候选像素的中点是(x+1,y-0.5)  
判别式 $d1=F(x+1,y-0.5)=b^2(x+1)^2+a2(y-0.5)^2-a^2b^2$
#### 增量:
$$
d1<0时  
d1'=F(x+2,y-0.5)=d_1+b^2(2x+3)  
$$
$$
d1>0时
d1'=F(x+2,y-1.5)=d_1+b^2(2x+3)+a^2(-2y+2)
$$

### 下半部分：

下一对候选像素的中点是(x+0.5,y-1)
判别式 $d_2=F(x+0.5,y-1)= b^2(x+0.5)^2+a^2(y-1)^2-a^2b^2$

增量的xy互换

# 区域填充算法
    – 区域填充即给出一个区域的边界，要求对边界范围内的所有像素单元赋予指定的颜色代码。
    – 区域填充中最常用的是多边形填色。
    – 多边形填色即给出一个多边形的边界，要求对多边形边界范围的所有像素单元赋予指定的颜色代码。
    – 要完成这个任务，一个首要的问题，是判断一个像素是在多边形内还是外。

### 填色算法分为两大类：  
    1.扫描线(Scanline)填色算法。  
    - 这类算法建立在多边形边界的矢量形式数据之上，可用于程序填色，也可用于交互填色。  

    2.种子(Seed)填色算法。  
    - 这类算法建立在多边形边界的图像形式数据之上，并还需提供多边形界内一点的坐标。所以，它一般只能用于人机交互填色，而难以用于程序填色。

## 1、活性边表法
活性边：和当前扫描线有交点的边
活性边表节点的数据结构：  
|x|Δx|$y_{max}$|
|---|---|---|
|当前扫描线与边的交点的x值|从当前扫描线到下一扫描线x的增量|活性边所交的最大值|

该数据结构代表扫描线与y轴平行时，每条扫描线扫描的过程中x遍历到活性边表中的每个x区间，并由Δx推断出下一条扫描线所对应的活性边表

<img src="活性边表.png">

新边表：若不规则图形在一个扫描线上出现了一条新的边，而活性边表中没有对应数据，则无法从上一条活性边中完整推出下一条完整活性边。则需要一个额外的数据结构维护每一个扫描线上出现的新的边，此数据结构即为新边表。新边表中存储的数据结构与活性边表相同。不同的是，这是一个链表集合，为每条扫描线维护了一个链表。

<img src="新边表.png">

伪代码：
```cpp
int color;多边形 polygon;

void polyfill(polygon,color)
{
    for(扫描线i)
    {
        初始化新边表头指针NET[i];
        将ymin=i的边放入NET[i];//即将边最底下的点放入新边表
    }

    y=最低扫描线号;
    初始化活性边表AET为空;
    for(扫描线i)
    {
        把NET[i]中的边节点用插入排序法插入AET表，使之按x递增的顺序排列;
        若允许多边形的边自相交，则用冒泡排序法对AET进行重新排列;//自相交：即图形内部的边存在相较
        遍历AET，把配对交点区间(左闭右开)上的像素(x,y)用drawPixel(int x,int y,int color)改写像素颜色值;
        遍历AET，把ymax=i的节点删除，并把ymax>i的节点的x值递增Δx;
    }
}
```

## 2、种子填充算法
采用递归实现，需要有一个已知的在填充区域内的点作为“种子”，种子填充算法分为四联通和八联通，分别对应种子的各个方向。

4联通的种子递归填充算法为：
```cpp
void BoundryFill4(int x,int y,int boundary_color,int new_color)
{
    int color = getPixelColor(x,y);
    if(color != new_color&&color != boundary_color)
    {
        drawPixel(x,y,new_color);
        //下面对四个方向做递归扫描
        BoundryFill4(x,y+1,boundary_color,new_color);
        BoundryFill4(x,y-1,boundary_color,new_color);
        BoundryFill4(x+1,y,boundary_color,new_color);
        BoundryFill4(x-1,y,boundary_color,new_color);
    }
}
```

# 裁剪
    裁剪是裁去窗口之外物体的一种操作

## 1、直线段裁剪
    直线段裁剪算法是复杂图元裁剪的基础。
    复杂的曲线可以通过折线段来近似，从而裁剪问题也可以转化为直线段的裁剪问题。

每段直线的端点都被赋予一组四位二进制代码，称为区域编码(region code，RC)，用来标识直线段端点相对于窗口边界及其延长线的位置。  

假设窗口是标准矩形，由上、下、左、右4条边界组成，延长窗口的4条边界形成9个区域。这样根据直线段的任一端点P(x，y)所处的窗口区域位置，可以赋予一组4位二进制编码，称为区域码RC=C3C2C1C0。C0代表左边界， C1代表右边界， C2代表下边界， C3代表上边界。

为了保证窗口内及窗口边界上直线段端点的编码为零，定义规则如下：  
C0：若端点的 x < wxl，则C0=1，否则C0=0。  
C1：若端点的x > wxr，则C1=1，否则C1=0。  
C2：若端点的y < wyb，则C2=1，否则C2=0。  
C3：若端点的y > wyt，则C3=1，否则C3=0。  

1.若直线段的两个端点的区域编码都为0，有RC0|RC1=0（二者按位相或的结果为零，即RC0=0且RC1=0），说明直线段的两个端点都在窗口内，应“简取”之（trivally accepted）。  

2.若直线段的两个端点的区域编码都不为0，且RC0&RC1≠0（二者按位相与的结果不为零，即RC0≠0且RC1≠0），说明直线段位于窗外的同一侧，或左方、或右方、或上方、或下方，应“简弃”之（trivally rejected）。  

3.若直线段既不满足“简取”也不满足“简弃”的条件，则需要与窗口进行“求交”判断。这时，直线段必然与窗口边界或窗口边界的延长线相交，在交点处把线段分为两段，其中一段完全在窗口外，可
弃之，另一段重复上述处理。

求交点代码：
```cpp
#define LEFT 1    //0001
#define RIGHT 2   //0010
#define BOTTOM 4  //0100
#define TOP 8     //1000
……
if(LEFT&code !=0)//判断是否与左侧相交
{x=XL;y=y1+(y2-y1)*(XL-x1)/(x2-x1);}
else if(RIGHT&code !=0)//判断是否与右侧相交
{x=XR;y=y1+(y2-y1)*(XR-x1)/(x2-x1);}
else if(BOTTOM&code !=0)//判断是否与下部相交
{y=YB;x=x1+(x2-x1)*(YB-y1)/(y2-y1);}
else if(TOP & code !=0)//判断是否与上部相交
{y=YT;x=x1+(x2-x1)*(YT-y1)/(y2-y1);}
……
```
<img src="交点计算.png">

## 2、中点分割法
从P0出发找最近可见点的方法：  

    p0 ——————pm—————— p1
    1. 先求出P0P1的中点Pm  
    2. 若P0Pm不是显然不可见的，并且P0P1在窗口中有可见部分，则距P0最近的可见点一定落在P0Pm上，所以用P0Pm代替P0P1;
    3. 否则取PmP1代替P0P1;
    4. 再对新的P0P1求中点Pm。重复上述过程，直到PmP1长度小于给定的控制常数为止，此时Pm收敛
    于交点。

从P1出发找最近可见点采用上面类似方法。

## 3、Cyrus-Beck算法
<img src="cyrus-beck.png">

与多边形的每条边均须计算一次
计算量大，只适用凸多边形

<img src="cyrus-beck算法的算法.png">

## 4、梁友栋算法 
即简化版Cyrus-Beck算法，裁剪多边形为四边形

实现代码:
```cpp
void LB_LineClip(float x1,float y1,float x2,float y2,float XL,float XR,float YB,float YT)
{
    float dx,dy,u1,u2;
    tl=0;tu=1;dx =x2-x1;dy =y2-y1;
    if(ClipT(-dx,x1-Xl,&u1,&u2)
        if(ClipT(dx,XR-x1, &u1,&u2)
            if(ClipT(-dy,y1-YB, &u1,&u2)
                if(ClipT(dy,YT-y1, &u1,&u2)
                {
                    displayline(x1+u1*dx,y1+u1*dy, x1+u2*dx,y1+u2*dy)
                    return;
                }
}

bool ClipT(float p,float q,float *u1,float *u2)
{
    float r;
    if(p<0)
    {
        r=q/p;
        if(r>*u2)
            return FALSE;
        else if(r>*u1)
        {
            *u1=r;
            return TRUE;
        }   
    }

    else if(p>0)
    {
        r=p/q;
        if(r<*u1)
            return FALSE;
        else if(r<*u2)
        {
            *u2=r;
            return TRUE;
        }
    }
    else if(q<0) 
        return FALSE;
    return TRUE;
}
```

## 5、多边形裁剪
对于多边形的每条边进行边裁剪，输出的点组成一个全新的多边形，这个多边形便是被裁减后的多边形。点的选取方式如下

<img src="多边形裁剪.png">

算法步骤如下：
1、已知：多边形顶点数组src，顶点个数n，
　 　　　　　定义新多边形顶点数组dest。

2、赋初值：用变量flag来标识：0表示在内侧，1表示在外侧。

 3、对多边形的n条边进行处理，对当前点号的考虑为：0～n-1。
 ```cpp
for(i=0;i<n;i++)
{
    if(当前第i个顶点是否在边界内侧？)
    {
        if(flag!=0) /*前一个点在外侧吗？*/
        {
            flag=0;/*从外到内的情况，将标志置0,作为下一次循环的前一点标志*/
            (dest + j) =求出交点;　/*将交点dest放入新多边形*/
            j++;
        }
        (dest + j)= (src + i); /*将当前点srci放入新多边形*/
        j++;
    }
    else
    {
        if(flag==0) /*前一个点在内侧吗？*/
        {
            flag=1;/*从内到外的情况，将标志置1,作为下一次循环的前一点标志*/
            (dest + j) =求出交点;　/*将交点dest放入新多边形*/
            j++;
        }
    }
    s= (src + i); /*将当前点作为下次循环的前一点*/
}

```

## 6、字符裁剪
字符裁剪有三种裁剪方式：  
1. 串精度：将包围字符串的外接矩形对窗口作裁剪。
2. 字符进度：将包围字符的外接矩形对窗口作裁剪
3. 像素精度：将笔划分解成直线段对窗口作裁剪

<img src="字符裁剪.png">
    

# 线宽线型、字符、反走样

## 1、线宽处理

### 1、直线线宽的处理
- 线刷：
    - 算法简单
    - 线的始末端是水平或垂直的
    - 斜率不同，线的宽度不同
    - 对于宽度为偶数个像素的直线会产生偏移

- 方形刷：
    - 方形中心对准单像素宽的线条上各个像素
    - 存在重复写像素的问题
    - 线条末端是水平或垂直的，且线宽与线条方向有关
    - 对于宽度为偶数个像素的直线会产生偏移

区域填充法：······

### 2、圆弧线宽的处理
- 线刷：
   - 在小于45°时使用水平刷子，在大于45°时用垂直刷子，即在经过曲线斜率为±1的点时刷子的方向要改变
- 方形刷：
   - 不需要改变刷子的方向，只需要沿着单像素宽的轨迹，把正方形中心对准轨迹上的像素，把方形内的像素全部置成线条颜色
- 区域填充法：······

## 2、线型处理
- 实线、虚线、点划线
- 线形的表示：布尔值序列

## 3、字符处理
计算机中字符由一个数字编码唯一标识。

表示方法：
1. 点阵字符
> 每个字符由一个位图表示
- 每一个字符有一个位图表示
- 存储空间大，但易于显示
- 显示时，先将位图从字库中读取出来，然后将位图写入帧缓冲器中

2. 矢量字符
> 由直线段和曲线段组成，记录字符的笔画信息
- 记录的是字符的笔画信息
- 存储量小，美观，变换方便，但需要光栅化之后才能显示

字符属性：
1. 字体
2. 字高
3. 字倾斜角
4. 字色

## 4、走样与反走样
走样：
> 用离散量表示连续量引起的失真现象称之为走样

反走样：
> 用于消除走样的技术便是反走样

反走样方法：
1. 提高分辨率

   - 将显示器的分辨率提高，显示出的直线段看起来就平直光滑了
   - 同时阶梯的宽度减小了
   - 同样会导致存储器和扫描转换时间的消耗增加
   - 每增加一倍的分辨率，将会减小一倍的阶梯宽度，以及花费4倍的存储器空间和2倍的扫描转换时间
   - 并且不能完全消除锯齿

2. 区域采样

   - 将直线段看作具有一定宽度的狭长矩形
   - 当直线段与像素相交时，求出两者相交区域的面积，然后根据相交区域面积的大小确定该位置像素的亮度
   - 区域采样的离散方法：
      - 首先将屏幕像素均分为n个子像素
      - 然后季孙中心点落在直线段内的子像素个数
      - 将该像素的屏幕亮度置为最大灰度值x相交区域面积的近似值
   - 简单区域采样的缺点：
      - 像素的亮度与相交区域的面积成正比，而与相交区域落在像素内的位置无关，这仍然会导致锯齿效应
      - 直线条上沿理想直线方向的相邻两个像素有时会有较大的灰度差

3. 加权区域采样

   - 使相交区域对像素亮度的贡献依赖于该区域与像素中心的距离
   - 当直线经过该像素时，像素的亮度时在两者相交区域上对滤波器进行积分的结果
   - 加权区域采样的离散方法：
      - 将屏幕像素划分为n个子像素
      - 求出所有中心位于直线段内的子像素
      - 计算这些子像素对原像素亮度贡献之和乘以像素的最大灰度值（与卷积运算类似），即通过加权表得出子像素的权重和，通过总权重求出亮度。
      - 加权表可取 $\frac{1}{16} \left[\begin{matrix} 1 & 2 & 3 \\4 & 5 & 6 \\7 & 8 & 9\end{matrix}\right]$

# 图形变换
## 1、二维图形变换
<img src="二维图形变换.png">
<img src="二维图形平移变换.png">
<img src="二维图形缩放变换.png">
<img src="二维图形对称变换.png">
<img src="二维图形旋转变换.png">
<img src="二维图形错切变换.png">

### 复合变换
$$
T_t = T_{t1}T_{t2}
$$
即多个变换矩阵的乘积

## 2、三维图形变换
<img src="三维图形变换.png">
平移变换：
<img src="三维图形平移变换.png">
缩放变换：
<img src="三维图形缩放变换.png">
绕轴坐标旋转变换:
<img src="三维图形绕坐标轴旋转变换.png">
绕任意轴旋转变换：
<img src="三维图形绕任意轴旋转变换.png">

## 投影变换分类
1. 平行投影

   - 用定义投影线方向的投影向量给出一个平行投影。
      - 当投影(向量)垂直于观察平面时，得到正平行投影(正投影)
      - 否则为斜平行投影


   - 当投影平面与某一坐标轴垂直时，得到的投影称为三视图(包括前视图、侧视图和顶(俯)视图)
   - 当投影平面不与某一坐标轴垂直时，形成的投影称为正轴测图，用来显示物体多个侧面
   - 投影平面三个法向量模|nx|、|ny|和|nz|全相等时，正轴测图为等轴测
   - 其中两个相等时为正二测
   - 各不相同时为正三测

2. 斜投影
   
   - 斜投影由两个角度确定
   - 点(x,y,z)投影到观察平面的(xp,yp)位置
   - 平面上正投影坐标是(x,y)
   - 从(x,y,z)到(xp,yp)的斜投影线与投影平面中的点(xp,yp)和(x,y)的连线交成角α
   - 点(xp,yp)和(x,y)的连线与观察平面x轴的夹角为β

如下图：  
<img src="斜投影.png">

斜投影的计算矩阵如下：  
<img src="斜投影计算矩阵.png">

- L1=0 (投射角α为90°)时得正投影
- L1为非零值时产生斜投影
- α通常的值为tanα=1，且所得视图称为斜等测投影
- 所有与投影平面垂直的直线在投影中长度不变
- 投影角α满足tanα=2时，所生成视图称斜二测投影
- 对于这样的角(≈63.4°)，与观察面垂直的线投影成一半长度
- β通常选择为30°或45°，这将显示出一物体的前面、侧面和顶面(或底面)的联合视图

3. 透视投影

   - 对于透视投影，物体的位置沿着收敛于某一点的直线变换到观察平面上，此点称为投影参考点(或投影中心)
   - 物体的投影视图由计算投影线与观察平面的交点而得
   - 透视投影生成真实感视图，但不保持比例关系
   - 对于同样大小的物体，离开投影平面较远的物体其投影图像比较近物体的图像较小
   - 灭点
      - 当物体用透视变换方程投影到观察平面上时，物体中不与观察平面平行的任一族平行线经过透视投影后收敛于一点，此点称为灭点
         - 三维环境中存在无数簇平行线，从而灭点也有无数个。
      - 平行于某一坐标轴的平行线的灭点称为主灭点
         - 用投影平面的方向控制主灭点数目，且据此将透视投影分类为一点、两点或三点透视
         - 投影中主灭点数目是由与观察盘面相交的主轴数目来决定的，主轴数目最多为三个

<img src="透视投影变换.png">
<img src="透视投影变换矩阵.png">


# 参数曲线和曲面基础

## 1、曲线曲面参数表示

$$
平面曲线：P(t)=[x(t),y(t)]\\
空间曲线：P(t)=[x(t),y(t),z(t)]
$$

平面曲线的显式表示：$y=f(x)$  
平面曲线的隐式表示：$f(x,y)=0$

显式或隐式表示的问题：
- 与坐标轴相关
- 可能出现斜率为无穷大的情形(如垂线)
- 不便于计算机编程
  
参数表示的优点：
- 便于处理斜率无穷大的情形，不会因此而中断计算
- 规格化的参数变量$t \in [0,1]$ ，使其相应的几何分量是有界的，而不必考虑边界问题
- 对曲线、曲面进行变换，可以对其参数方程直接进行几何变换
- 便于把低维空间中的曲线、曲面拓展到高维空间
- 易于用矢量和矩阵表示几何分量，简化计算
- 有更大的自由度来控制曲线、曲面的形状

位置矢量：$P(t)=[x(t),y(t),z(t)]$  
切矢量：
   - 将弧长s作为参数，则$T={dP\over ds}=lim_{Δs→0}{ΔP\over ΔS}$  为单位切矢量
   - $T={dP\over dS}={P'(t)\over |P'(t)|}$

法矢量：
   - 与 ${dT\over dS}$ (就是$T'(s)$换了个写法) 平行的法矢量称为曲线在该点的主法矢量
   - 矢量积 $B=T\times N$ 是第三个单位矢量，它垂直于T和N。把平行于矢量B的法矢量称为曲线的副法矢量  
   - 故可推出：<img src="主法矢量与副法矢量的计算.png">
   - 需注意上述关于N的等式其分母应为: $|(P'(t)\times P''(t))\cdot P'(t)|$
   - T、N、B共同构成了曲线上的活动坐标架: <img src="曲线的法矢量.png">

## 2、曲率和挠率
1. 曲率
   1. 其几何意义是曲线的单位切矢量对弧长的转动率$|{dT\over dS}|$
   2. 曲率k的倒数$\rho={1\over k}$
   3. $k=lim_{ΔS→0}|{Δ\theta\over ΔS}|$
   4. 有$T'=kN$
   5. 计算公式如下：<img src="曲率计算.png">
2. 挠率
   1. 挠率的绝对值等于夫法线方向对于弧长的转动率${dB\over dS}$
   2. $|\tau|=lim_{ΔS→0}|{Δ\phi\over ΔS}|$
   3. 计算公式如下：<img src="挠率计算.png">
   4. 计算公式的分子应为$(P'(t)\times P''(t))\cdot P'''(t)$
   5. 分子是一个向量，但分母为向量的平方->向量的平方即该向量的模的平方，为一个值

## 3、插值、拟合、逼近、光顺

- 插值
  - 给定一组有序的数据点$P_i,i=0,1,2,3,...,n$，构造一条曲线顺序通过所有数据点，称为对这些数据点进行插值，所构造的曲线称为插值曲线
  - 线性插值
    - 假设给定函数$f(x)$在两个不同的点$x_1$和$x_2$的值，用一个线性函数 $y=ax+b$ 近似代替，称为线性插值函数
  - 抛物线插值
    - 已知在三个互异点$x_1,x_2,x_3$的函数值为$y_1,y_2,y_3$，要求构造一个函数 $\phi(x)=ax^2+bx+c$使得抛物线在节点$x_1,x_2,x_3$处与$f(x)$在节点$x_1,x_2,x_3$处的值相等，称为抛物线插值函数
- 拟合
  - 构造一条曲线使之在某种意义下最接近给定的数据点(但未必通过)，所构造的曲线为拟合曲线
- 逼近
  - 在计算数学中，逼近通常指用一些性质较好的函数近似表示一些性质不好的函数。在计算机图形学中，逼近继承了这方面的含义，因此插值和拟合都可以视为逼近
- 光顺
  - 光顺指曲线的拐点不能太多
  - 对于平面曲线而言，相对光顺的条件是：
    - 具有二阶几何连续性($G^2$)
    - 不存在多余拐点和奇异点
    - 曲率变换比较小

## 4、参数曲线的代数和几何形式
- 代数形式：
  - <img src="参数曲线的代数形式.png">
- 矢量形式：
  - $P(t)=a_3t^3+a_2t^2+a_1t+a_0 \\  t\in[0,1]$
- 几何形式：
  - <img src="参数曲线的几何形式.png">
  - 令$F_0(t)=2t^3-3t^2+1\\F_1(t)=-2t^3+3t^2\\G_0(t)=t^3-2t^2+t\\G_1(t)=t^3-t^2$
  - 则可得出三次Hermite曲线的几何形式：$P(t)=F_0P_0+F_1P_1+G_0P'_0+G_1P'_1 \ where \ t\in [0,1]$
  - $P_0,P_1,P'_0,p'_1$是几何系数
  - $F_0,F_1,G_0,G_1$是调和函数

## 5、连续性
曲线之间连接的光滑度，有两种度量方式：
1. 参数连续性
   1. 组合参数曲线在连接处具有直到$n$阶连续导矢，即$n$阶连续可微，这类光滑度称之为$C^n$或$n$阶参数连续性
2. 几何连续性
   1. 组合曲线在连接处满足不同于$C^n$的某一组约束条件，称为具有$n$阶几何连续性，记为$G^n$

- 若要求两曲线在结合处达到$C^n$或$G^n$连续，即两曲线在结合处位置连续
- 若要求在结合处达到$G^1$连续，就是说两条曲线在结合处满足$G^0$连续的条件下，并有公共的切矢量$Q'(0)=aP'(1)$
- 当a=1时，$G^1$连续就成为$C^1$连续
- 如图：<img src="参数曲线和曲面基础.png">

